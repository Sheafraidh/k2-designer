"""
SQL Generation Dialog for generating database scripts.
"""

import sys
import os
from typing import List, Dict, Any

try:
    from jinja2 import Environment, FileSystemLoader, Template
    JINJA2_AVAILABLE = True
except ImportError:
    JINJA2_AVAILABLE = False
    print("Warning: jinja2 not available, falling back to basic SQL generation")

# Suppress macOS NSOpenPanel warning
if sys.platform == "darwin":
    import io
    import contextlib
    
    @contextlib.contextmanager
    def suppress_stdout_stderr():
        """Suppress stdout and stderr temporarily."""
        with open(os.devnull, "w") as devnull:
            old_stdout = sys.stdout
            old_stderr = sys.stderr
            try:
                sys.stdout = devnull
                sys.stderr = devnull
                yield
            finally:
                sys.stdout = old_stdout
                sys.stderr = old_stderr

from PyQt6.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QPushButton, 
                             QTabWidget, QTreeWidget, QTreeWidgetItem, QCheckBox,
                             QLabel, QLineEdit, QFileDialog, QProgressBar, 
                             QTextEdit, QSplitter, QGroupBox, QMessageBox,
                             QApplication)
from PyQt6.QtCore import Qt, QThread, pyqtSignal
from PyQt6.QtGui import QFont

from ..controllers.template_manager import TemplateManager, TemplateInfo
from ..controllers.user_settings import UserSettingsManager


class SqlGeneratorWorker(QThread):
    """Worker thread for generating SQL files."""
    
    progress_updated = pyqtSignal(int)
    log_message = pyqtSignal(str)
    finished = pyqtSignal()
    error_occurred = pyqtSignal(str)
    
    def __init__(self, project, output_dir: str, selected_objects: Dict[str, List[Any]], 
                 single_file: bool = False, single_filename: str = "database_objects.sql",
                 template_selections: Dict[str, List[TemplateInfo]] = None):
        super().__init__()
        self.project = project
        self.output_dir = output_dir
        self.selected_objects = selected_objects
        self.single_file = single_file
        self.single_filename = single_filename or "database_objects.sql"
        self.template_selections = template_selections or {}  # object_id -> [templates]
        self.total_objects = sum(len(objects) for objects in selected_objects.values())
        self.current_progress = 0
        self._setup_templates()
    
    def _setup_templates(self):
        """Setup Jinja2 template environment."""
        self.jinja_env = None
        self.templates_cache = {}  # Cache loaded templates by filepath

        if JINJA2_AVAILABLE:
            # Get the templates directory path
            current_dir = os.path.dirname(os.path.abspath(__file__))
            project_root = os.path.dirname(os.path.dirname(os.path.dirname(current_dir)))
            self.templates_dir = os.path.join(project_root, 'templates')

            if os.path.exists(self.templates_dir):
                try:
                    # Create environment that can load from subdirectories
                    self.jinja_env = Environment(loader=FileSystemLoader(self.templates_dir))
                    print(f"‚úÖ Jinja2 environment ready: {self.templates_dir}")
                except Exception as e:
                    print(f"‚ö†Ô∏è Error setting up Jinja2 environment: {e}")
                    self.jinja_env = None
            else:
                print(f"‚ö†Ô∏è Templates directory not found: {self.templates_dir}")

    def run(self):
        """Generate SQL files for selected objects."""
        try:
            self.log_message.emit("üöÄ Starting SQL generation...")
            self.log_message.emit(f"üìÅ Output directory: {self.output_dir}")
            
            if self.single_file:
                self._generate_single_file()
            else:
                self._generate_separate_files()
            
            self.log_message.emit("‚úÖ SQL generation completed successfully!")
            self.finished.emit()
            
        except Exception as e:
            self.error_occurred.emit(f"Error during generation: {str(e)}")
    
    def _generate_single_file(self):
        """Generate all objects into a single SQL file."""
        filepath = os.path.join(self.output_dir, self.single_filename)
        self.log_message.emit(f"üìÑ Generating single file: {self.single_filename}")
        
        sql_parts = []
        sql_parts.append("-- Database Objects SQL Script")
        sql_parts.append("-- Generated by K2 Designer")
        sql_parts.append(f"-- Total objects: {self.total_objects}")
        sql_parts.append("")
        
        # Generate tables
        if 'tables' in self.selected_objects:
            sql_parts.append("-- ==========================================")
            sql_parts.append("-- TABLES")
            sql_parts.append("-- ==========================================")
            sql_parts.append("")
            
            for table in self.selected_objects['tables']:
                sql_parts.append(self._create_table_sql(table))
                sql_parts.append("")
                self._update_progress()
        
        # Generate sequences
        if 'sequences' in self.selected_objects:
            sql_parts.append("-- ==========================================")
            sql_parts.append("-- SEQUENCES")
            sql_parts.append("-- ==========================================")
            sql_parts.append("")
            
            for sequence in self.selected_objects['sequences']:
                sql_parts.append(self._create_sequence_sql(sequence))
                sql_parts.append("")
                self._update_progress()
        
        # Generate users/owners
        if 'owners' in self.selected_objects:
            sql_parts.append("-- ==========================================")
            sql_parts.append("-- USERS/OWNERS")
            sql_parts.append("-- ==========================================")
            sql_parts.append("")
            
            for owner in self.selected_objects['owners']:
                sql_parts.append(self._create_owner_sql(owner))
                sql_parts.append("")
                self._update_progress()
        
        # Write to file
        try:
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write("\n".join(sql_parts))
            
            self.log_message.emit(f"‚úÖ Generated: {self.single_filename}")
            
        except Exception as e:
            self.log_message.emit(f"‚ùå Error generating {self.single_filename}: {str(e)}")
    
    def _generate_separate_files(self):
        """Generate separate files for each object using selected templates."""
        # Generate tables
        if 'tables' in self.selected_objects:
            for table in self.selected_objects['tables']:
                object_id = f"table_{table.owner}.{table.name}"
                templates = self.template_selections.get(object_id, [])

                if templates:
                    for template_info in templates:
                        self._generate_from_template(table, template_info, 'table')
                else:
                    # Fallback to default
                    self._generate_table_sql(table)

                self._update_progress()
        
        # Generate sequences
        if 'sequences' in self.selected_objects:
            for sequence in self.selected_objects['sequences']:
                object_id = f"sequence_{sequence.owner}.{sequence.name}"
                templates = self.template_selections.get(object_id, [])

                if templates:
                    for template_info in templates:
                        self._generate_from_template(sequence, template_info, 'sequence')
                else:
                    # Fallback to default
                    self._generate_sequence_sql(sequence)

                self._update_progress()
        
        # Generate users/owners
        if 'owners' in self.selected_objects:
            for owner in self.selected_objects['owners']:
                object_id = f"owner_{owner.name}"
                templates = self.template_selections.get(object_id, [])

                if templates:
                    for template_info in templates:
                        self._generate_from_template(owner, template_info, 'owner')
                else:
                    # Fallback to default
                    self._generate_owner_sql(owner)

                self._update_progress()
    
    def _update_progress(self):
        """Update progress."""
        self.current_progress += 1
        progress_percent = int((self.current_progress / self.total_objects) * 100)
        self.progress_updated.emit(progress_percent)
    
    def _generate_from_template(self, obj, template_info: TemplateInfo, obj_type: str):
        """Generate SQL from a specific template."""
        # Construct filename
        if obj_type == 'table':
            base_name = f"{obj.name.lower()}"
            obj_name = f"{obj.owner}.{obj.name}"
            context = {'table': obj}
        elif obj_type == 'sequence':
            base_name = f"{obj.name.lower()}_seq"
            obj_name = f"{obj.owner}.{obj.name}"
            context = {'sequence': obj}
        elif obj_type == 'owner':
            base_name = f"{obj.name.lower()}_user"
            obj_name = obj.name
            context = {'owner': obj}
        else:
            base_name = "object"
            obj_name = "unknown"
            context = {}

        # Create filename with template name
        template_base = template_info.filename.replace('.sql.j2', '')
        filename = f"{base_name}_{template_base}.sql"
        filepath = os.path.join(self.output_dir, filename)

        try:
            # Load and render template
            if self.jinja_env:
                # Get relative path from templates dir
                rel_path = os.path.relpath(template_info.filepath, self.templates_dir)
                # Normalize path separators for Jinja2
                template_path = rel_path.replace(os.sep, '/')

                template = self.jinja_env.get_template(template_path)
                sql_content = template.render(**context)

                with open(filepath, 'w', encoding='utf-8') as f:
                    f.write(sql_content)

                self.log_message.emit(f"üìÑ Generated: {filename} using {template_info.name}")
            else:
                self.log_message.emit(f"‚ö†Ô∏è Jinja2 not available, skipping: {filename}")

        except Exception as e:
            self.log_message.emit(f"‚ùå Error generating {filename}: {str(e)}")


    def _generate_table_sql(self, table):
        """Generate SQL for a table."""
        filename = f"{table.name.lower()}.sql"
        filepath = os.path.join(self.output_dir, filename)
        
        try:
            sql_content = self._create_table_sql(table)
            
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(sql_content)
            
            self.log_message.emit(f"üìÑ Generated: {filename}")
            
        except Exception as e:
            self.log_message.emit(f"‚ùå Error generating {filename}: {str(e)}")
    
    def _generate_sequence_sql(self, sequence):
        """Generate SQL for a sequence."""
        filename = f"{sequence.name.lower()}_seq.sql"
        filepath = os.path.join(self.output_dir, filename)
        
        try:
            sql_content = self._create_sequence_sql(sequence)
            
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(sql_content)
            
            self.log_message.emit(f"üìÑ Generated: {filename}")
            
        except Exception as e:
            self.log_message.emit(f"‚ùå Error generating {filename}: {str(e)}")
    
    def _generate_owner_sql(self, owner):
        """Generate SQL for an owner/user."""
        filename = f"{owner.name.lower()}_user.sql"
        filepath = os.path.join(self.output_dir, filename)
        
        try:
            sql_content = self._create_owner_sql(owner)
            
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(sql_content)
            
            self.log_message.emit(f"üìÑ Generated: {filename}")
            
        except Exception as e:
            self.log_message.emit(f"‚ùå Error generating {filename}: {str(e)}")
    
    def _create_table_sql(self, table) -> str:
        """Create CREATE TABLE SQL statement using Jinja2 template if available."""
        if self.jinja_env:
            try:
                # Try to load default create table template
                template = self.jinja_env.get_template('tables/create_table.sql.j2')
                return template.render(table=table)
            except Exception as e:
                print(f"‚ö†Ô∏è Error rendering table template, falling back to basic generation: {e}")
        
        # Fallback to basic SQL generation
        sql_parts = []
        
        # Table creation
        sql_parts.append(f"-- Table: {table.owner}.{table.name}")
        sql_parts.append(f"-- Generated by K2 Designer")
        sql_parts.append("")
        sql_parts.append(f"CREATE TABLE {table.owner}.{table.name} (")
        
        # Columns
        column_definitions = []
        for column in table.columns:
            col_def = f"    {column.name} {column.data_type}"
            if not column.nullable:
                col_def += " NOT NULL"
            if column.default:
                col_def += f" DEFAULT {column.default}"
            column_definitions.append(col_def)
        
        sql_parts.append(",\n".join(column_definitions))
        sql_parts.append(");")
        
        # Comments
        if table.comment:
            sql_parts.append("")
            sql_parts.append(f"COMMENT ON TABLE {table.owner}.{table.name} IS '{table.comment}';")
        
        for column in table.columns:
            if column.comment:
                sql_parts.append(f"COMMENT ON COLUMN {table.owner}.{table.name}.{column.name} IS '{column.comment}';")
        
        return "\n".join(sql_parts)
    
    def _create_sequence_sql(self, sequence) -> str:
        """Create CREATE SEQUENCE SQL statement using Jinja2 template if available."""
        if self.jinja_env:
            try:
                # Try to load default create sequence template
                template = self.jinja_env.get_template('sequences/create_sequence.sql.j2')
                return template.render(sequence=sequence)
            except Exception as e:
                print(f"‚ö†Ô∏è Error rendering sequence template, falling back to basic generation: {e}")
        
        # Fallback to basic SQL generation
        sql_parts = []
        
        sql_parts.append(f"-- Sequence: {sequence.owner}.{sequence.name}")
        sql_parts.append(f"-- Generated by K2 Designer")
        sql_parts.append("")
        
        seq_sql = f"CREATE SEQUENCE {sequence.owner}.{sequence.name}"
        
        if sequence.start_with is not None:
            seq_sql += f" START WITH {sequence.start_with}"
        if sequence.increment_by is not None:
            seq_sql += f" INCREMENT BY {sequence.increment_by}"
        if sequence.min_value is not None:
            seq_sql += f" MINVALUE {sequence.min_value}"
        if sequence.max_value is not None:
            seq_sql += f" MAXVALUE {sequence.max_value}"
        if sequence.cache_size is not None:
            seq_sql += f" CACHE {sequence.cache_size}"
        if sequence.cycle:
            seq_sql += " CYCLE"
        else:
            seq_sql += " NOCYCLE"
        
        seq_sql += ";"
        sql_parts.append(seq_sql)
        
        if sequence.comment:
            sql_parts.append("")
            sql_parts.append(f"COMMENT ON SEQUENCE {sequence.owner}.{sequence.name} IS '{sequence.comment}';")
        
        return "\n".join(sql_parts)
    
    def _create_owner_sql(self, owner) -> str:
        """Create user/owner SQL statements using Jinja2 template if available."""
        if self.jinja_env:
            try:
                # Try to load default create user template
                template = self.jinja_env.get_template('users/create_user.sql.j2')
                return template.render(owner=owner)
            except Exception as e:
                print(f"‚ö†Ô∏è Error rendering user template, falling back to basic generation: {e}")
        
        # Fallback to basic SQL generation
        sql_parts = []
        
        sql_parts.append(f"-- User: {owner.name}")
        sql_parts.append(f"-- Generated by K2 Designer")
        sql_parts.append("")
        
        # Create user
        sql_parts.append(f"CREATE USER {owner.name}")
        if owner.default_tablespace:
            sql_parts.append(f"    DEFAULT TABLESPACE {owner.default_tablespace}")
        if owner.temp_tablespace:
            sql_parts.append(f"    TEMPORARY TABLESPACE {owner.temp_tablespace}")
        if owner.default_index_tablespace:
            sql_parts.append(f"    DEFAULT TABLESPACE FOR INDEXES {owner.default_index_tablespace}")
        sql_parts.append(";")
        
        # Grant basic privileges
        sql_parts.append("")
        sql_parts.append(f"GRANT CONNECT TO {owner.name};")
        sql_parts.append(f"GRANT RESOURCE TO {owner.name};")
        
        # Add comment if available
        if owner.comment:
            sql_parts.append("")
            sql_parts.append(f"COMMENT ON USER {owner.name} IS '{owner.comment}';")
        
        return "\n".join(sql_parts)


class GenerateDialog(QDialog):
    """Dialog for generating SQL scripts from project objects."""
    
    def __init__(self, project, parent=None):
        super().__init__(parent)
        self.project = project
        self.selected_objects = {'tables': [], 'sequences': [], 'owners': []}
        self.template_selections = {}  # object_id -> [TemplateInfo]
        self.worker = None
        
        # Setup user settings
        self.user_settings = UserSettingsManager()

        # Setup template manager
        current_dir = os.path.dirname(os.path.abspath(__file__))
        project_root = os.path.dirname(os.path.dirname(os.path.dirname(current_dir)))
        templates_dir = os.path.join(project_root, 'templates')
        self.template_manager = TemplateManager(templates_dir)

        self.setWindowTitle("Generate SQL Scripts")
        self.setModal(True)
        self.resize(1200, 700)  # Wider to accommodate template tree

        self._setup_ui()
        self._populate_trees()
        self._load_default_output_directory()

    def _setup_ui(self):
        """Setup the dialog UI."""
        layout = QVBoxLayout(self)
        
        # Output directory selection
        dir_group = QGroupBox("Output Directory")
        dir_layout = QHBoxLayout(dir_group)
        
        self.output_dir_edit = QLineEdit()
        self.output_dir_edit.setPlaceholderText("Select output directory...")
        self.browse_btn = QPushButton("Browse...")
        self.browse_btn.clicked.connect(self._browse_output_dir)
        
        dir_layout.addWidget(QLabel("Output Directory:"))
        dir_layout.addWidget(self.output_dir_edit)
        dir_layout.addWidget(self.browse_btn)
        
        layout.addWidget(dir_group)
        
        # Generation options
        options_group = QGroupBox("Generation Options")
        options_layout = QVBoxLayout(options_group)
        
        self.single_file_checkbox = QCheckBox("Generate all objects to a single file")
        self.single_file_checkbox.setToolTip("When checked, all selected objects will be generated into one SQL file instead of separate files")
        
        single_file_layout = QHBoxLayout()
        single_file_layout.addWidget(self.single_file_checkbox)
        
        self.single_filename_edit = QLineEdit("database_objects.sql")
        self.single_filename_edit.setEnabled(False)
        self.single_filename_edit.setToolTip("Filename for the combined SQL file")
        
        single_file_layout.addWidget(QLabel("Filename:"))
        single_file_layout.addWidget(self.single_filename_edit)
        single_file_layout.addStretch()
        
        options_layout.addLayout(single_file_layout)
        
        # Connect checkbox to enable/disable filename field
        self.single_file_checkbox.toggled.connect(self._on_single_file_toggled)
        
        layout.addWidget(options_group)
        
        # Main horizontal splitter (Template Tree | Object Selection)
        main_splitter = QSplitter(Qt.Orientation.Horizontal)

        # LEFT SIDE: Template Tree
        template_group = QGroupBox("Available Templates")
        template_layout = QVBoxLayout(template_group)

        template_help = QLabel("Select templates to generate for each object.\nTemplates are organized by directory.")
        template_help.setWordWrap(True)
        template_help.setStyleSheet("color: gray; font-size: 10px;")
        template_layout.addWidget(template_help)

        self.template_tree = QTreeWidget()
        self.template_tree.setHeaderLabels(["Template", "Description"])
        self.template_tree.setColumnWidth(0, 200)
        self.template_tree.itemChanged.connect(self._on_template_item_changed)
        template_layout.addWidget(self.template_tree)

        main_splitter.addWidget(template_group)

        # RIGHT SIDE: Vertical splitter for object selection and progress
        right_splitter = QSplitter(Qt.Orientation.Vertical)

        # Object selection tabs
        selection_group = QGroupBox("Select Objects to Generate")
        selection_layout = QVBoxLayout(selection_group)
        
        self.tab_widget = QTabWidget()
        self.tab_widget.currentChanged.connect(self._on_tab_changed)

        # Tables tab
        self.tables_tree = QTreeWidget()
        self.tables_tree.setHeaderLabels(["Tables", "Owner", "Columns"])
        self.tables_tree.itemChanged.connect(self._on_table_item_changed)
        self.tables_tree.itemSelectionChanged.connect(lambda: self._update_template_tree_for_selection('table'))
        self.tab_widget.addTab(self.tables_tree, "Tables")
        
        # Sequences tab
        self.sequences_tree = QTreeWidget()
        self.sequences_tree.setHeaderLabels(["Sequences", "Owner", "Properties"])
        self.sequences_tree.itemChanged.connect(self._on_sequence_item_changed)
        self.sequences_tree.itemSelectionChanged.connect(lambda: self._update_template_tree_for_selection('sequence'))
        self.tab_widget.addTab(self.sequences_tree, "Sequences")
        
        # Owners/Users tab
        self.owners_tree = QTreeWidget()
        self.owners_tree.setHeaderLabels(["Users/Owners", "Default Tablespace", "Properties"])
        self.owners_tree.itemChanged.connect(self._on_owner_item_changed)
        self.owners_tree.itemSelectionChanged.connect(lambda: self._update_template_tree_for_selection('user'))
        self.tab_widget.addTab(self.owners_tree, "Users")
        
        selection_layout.addWidget(self.tab_widget)
        right_splitter.addWidget(selection_group)

        # Progress and log section
        progress_group = QGroupBox("Generation Progress")
        progress_layout = QVBoxLayout(progress_group)
        
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        progress_layout.addWidget(self.progress_bar)
        
        self.log_text = QTextEdit()
        self.log_text.setMaximumHeight(150)
        self.log_text.setFont(QFont("Consolas", 9))
        progress_layout.addWidget(self.log_text)
        
        right_splitter.addWidget(progress_group)

        main_splitter.addWidget(right_splitter)

        # Set splitter proportions (30% template tree, 70% objects)
        main_splitter.setSizes([360, 840])

        layout.addWidget(main_splitter)

        # Buttons
        button_layout = QHBoxLayout()
        
        self.select_all_btn = QPushButton("Select All")
        self.select_all_btn.clicked.connect(self._select_all)

        self.select_none_btn = QPushButton("Select None")
        self.select_none_btn.clicked.connect(self._select_none)
        
        button_layout.addWidget(self.select_all_btn)
        button_layout.addWidget(self.select_none_btn)
        button_layout.addStretch()
        
        self.generate_btn = QPushButton("Generate SQL")
        self.generate_btn.clicked.connect(self._generate_sql)
        
        self.close_btn = QPushButton("Close")
        self.close_btn.clicked.connect(self.close)
        
        button_layout.addWidget(self.generate_btn)
        button_layout.addWidget(self.close_btn)
        
        layout.addLayout(button_layout)

        # Populate template tree
        self._populate_template_tree()

    def _populate_template_tree(self):
        """Populate the template tree with available templates."""
        self.template_tree.clear()

        # Get all template groups
        groups = self.template_manager.get_groups()

        for group_name in groups:
            # Create group node
            group_item = QTreeWidgetItem(self.template_tree)
            group_item.setText(0, group_name.title())
            group_item.setText(1, f"Templates for {group_name}")
            group_item.setExpanded(True)

            # Add templates for this group
            templates = self.template_manager.get_templates_for_group(group_name)
            for template_info in templates:
                template_item = QTreeWidgetItem(group_item)
                template_item.setText(0, template_info.name)
                template_item.setText(1, template_info.description)
                template_item.setFlags(template_item.flags() | Qt.ItemFlag.ItemIsUserCheckable)
                template_item.setCheckState(0, Qt.CheckState.Unchecked)
                template_item.setData(0, Qt.ItemDataRole.UserRole, template_info)

    def _on_tab_changed(self, index):
        """Handle tab change to update template tree."""
        # Determine object type from tab
        if index == 0:  # Tables
            self._update_template_tree_for_selection('table')
        elif index == 1:  # Sequences
            self._update_template_tree_for_selection('sequence')
        elif index == 2:  # Users
            self._update_template_tree_for_selection('user')

    def _update_template_tree_for_selection(self, object_type: str):
        """Update template tree to show only relevant templates for the selected object type."""
        # Enable/disable templates based on object type
        root = self.template_tree.invisibleRootItem()

        for i in range(root.childCount()):
            group_item = root.child(i)

            for j in range(group_item.childCount()):
                template_item = group_item.child(j)
                template_info = template_item.data(0, Qt.ItemDataRole.UserRole)

                if template_info:
                    # Enable only if template matches object type
                    is_enabled = template_info.object_type == object_type
                    template_item.setDisabled(not is_enabled)

                    # Set visual style for disabled items
                    if not is_enabled:
                        template_item.setForeground(0, Qt.GlobalColor.gray)
                        template_item.setForeground(1, Qt.GlobalColor.gray)
                    else:
                        template_item.setForeground(0, Qt.GlobalColor.black)
                        template_item.setForeground(1, Qt.GlobalColor.black)

    def _on_template_item_changed(self, item, column):
        """Handle template item check state change."""
        if column != 0:
            return

        template_info = item.data(0, Qt.ItemDataRole.UserRole)
        if not template_info:
            return  # This is a group item, not a template

        # Get currently selected object from the active tab
        current_tab_index = self.tab_widget.currentIndex()

        if current_tab_index == 0:  # Tables
            selected_items = self.tables_tree.selectedItems()
            if selected_items:
                for sel_item in selected_items:
                    table = sel_item.data(0, Qt.ItemDataRole.UserRole)
                    if table:
                        object_id = f"table_{table.owner}.{table.name}"
                        self._update_template_selection(object_id, template_info, item.checkState(0))

        elif current_tab_index == 1:  # Sequences
            selected_items = self.sequences_tree.selectedItems()
            if selected_items:
                for sel_item in selected_items:
                    sequence = sel_item.data(0, Qt.ItemDataRole.UserRole)
                    if sequence:
                        object_id = f"sequence_{sequence.owner}.{sequence.name}"
                        self._update_template_selection(object_id, template_info, item.checkState(0))

        elif current_tab_index == 2:  # Users
            selected_items = self.owners_tree.selectedItems()
            if selected_items:
                for sel_item in selected_items:
                    owner = sel_item.data(0, Qt.ItemDataRole.UserRole)
                    if owner:
                        object_id = f"owner_{owner.name}"
                        self._update_template_selection(object_id, template_info, item.checkState(0))

    def _update_template_selection(self, object_id: str, template_info: TemplateInfo, check_state):
        """Update template selection for an object."""
        if object_id not in self.template_selections:
            self.template_selections[object_id] = []

        if check_state == Qt.CheckState.Checked:
            if template_info not in self.template_selections[object_id]:
                self.template_selections[object_id].append(template_info)
        else:
            if template_info in self.template_selections[object_id]:
                self.template_selections[object_id].remove(template_info)

    def _browse_output_dir(self):
        """Browse for output directory."""
        # Start from the saved directory if available
        start_dir = self.user_settings.output_directory or ""

        if sys.platform == "darwin":
            # Suppress macOS NSOpenPanel warning
            with suppress_stdout_stderr():
                dir_path = QFileDialog.getExistingDirectory(
                    self, "Select Output Directory", start_dir
                )
        else:
            dir_path = QFileDialog.getExistingDirectory(
                self, "Select Output Directory", start_dir
            )
        
        if dir_path:
            self.output_dir_edit.setText(dir_path)
            # Save to user settings for next time
            self.user_settings.output_directory = dir_path

    def _load_default_output_directory(self):
        """Load the default output directory from user settings."""
        default_dir = self.user_settings.output_directory
        if default_dir and os.path.exists(default_dir):
            self.output_dir_edit.setText(default_dir)

    def _populate_trees(self):
        """Populate the tree widgets with project objects."""
        # Populate tables
        for table in self.project.tables:
            item = QTreeWidgetItem(self.tables_tree)
            item.setText(0, table.name)
            item.setText(1, table.owner)
            item.setText(2, f"{len(table.columns)} columns")
            item.setFlags(item.flags() | Qt.ItemFlag.ItemIsUserCheckable)
            item.setCheckState(0, Qt.CheckState.Unchecked)
            item.setData(0, Qt.ItemDataRole.UserRole, table)
        
        # Populate sequences
        for sequence in self.project.sequences:
            item = QTreeWidgetItem(self.sequences_tree)
            item.setText(0, sequence.name)
            item.setText(1, sequence.owner)
            item.setText(2, f"Start: {sequence.start_with}, Inc: {sequence.increment_by}")
            item.setFlags(item.flags() | Qt.ItemFlag.ItemIsUserCheckable)
            item.setCheckState(0, Qt.CheckState.Unchecked)
            item.setData(0, Qt.ItemDataRole.UserRole, sequence)
        
        # Populate owners
        for owner in self.project.owners:
            item = QTreeWidgetItem(self.owners_tree)
            item.setText(0, owner.name)
            item.setText(1, owner.default_tablespace or "")
            item.setText(2, f"Editionable: {owner.editionable}")
            item.setFlags(item.flags() | Qt.ItemFlag.ItemIsUserCheckable)
            item.setCheckState(0, Qt.CheckState.Unchecked)
            item.setData(0, Qt.ItemDataRole.UserRole, owner)
        
        # Expand all trees
        self.tables_tree.expandAll()
        self.sequences_tree.expandAll()
        self.owners_tree.expandAll()
    
    def _on_table_item_changed(self, item, column):
        """Handle table item check state change."""
        if column == 0:  # Only handle first column
            table = item.data(0, Qt.ItemDataRole.UserRole)
            if item.checkState(0) == Qt.CheckState.Checked:
                if table not in self.selected_objects['tables']:
                    self.selected_objects['tables'].append(table)
            else:
                if table in self.selected_objects['tables']:
                    self.selected_objects['tables'].remove(table)
    
    def _on_sequence_item_changed(self, item, column):
        """Handle sequence item check state change."""
        if column == 0:
            sequence = item.data(0, Qt.ItemDataRole.UserRole)
            if item.checkState(0) == Qt.CheckState.Checked:
                if sequence not in self.selected_objects['sequences']:
                    self.selected_objects['sequences'].append(sequence)
            else:
                if sequence in self.selected_objects['sequences']:
                    self.selected_objects['sequences'].remove(sequence)
    
    def _on_owner_item_changed(self, item, column):
        """Handle owner item check state change."""
        if column == 0:
            owner = item.data(0, Qt.ItemDataRole.UserRole)
            if item.checkState(0) == Qt.CheckState.Checked:
                if owner not in self.selected_objects['owners']:
                    self.selected_objects['owners'].append(owner)
            else:
                if owner in self.selected_objects['owners']:
                    self.selected_objects['owners'].remove(owner)
    
    def _on_single_file_toggled(self, checked):
        """Handle single file checkbox toggle."""
        self.single_filename_edit.setEnabled(checked)
        if checked:
            self.single_filename_edit.setFocus()
    
    def _select_all(self):
        """Select all items in current tab."""
        current_widget = self.tab_widget.currentWidget()
        self._set_all_items_checked(current_widget, True)
    
    def _select_none(self):
        """Deselect all items in current tab."""
        current_widget = self.tab_widget.currentWidget()
        self._set_all_items_checked(current_widget, False)
    
    def _set_all_items_checked(self, tree_widget, checked):
        """Set all items in tree widget to checked/unchecked."""
        for i in range(tree_widget.topLevelItemCount()):
            item = tree_widget.topLevelItem(i)
            item.setCheckState(0, Qt.CheckState.Checked if checked else Qt.CheckState.Unchecked)
    
    def _generate_sql(self):
        """Start SQL generation process."""
        # Validate inputs
        if not self.output_dir_edit.text().strip():
            QMessageBox.warning(self, "No Directory", "Please select an output directory.")
            return
        
        if not os.path.exists(self.output_dir_edit.text()):
            QMessageBox.warning(self, "Invalid Directory", "The selected output directory does not exist.")
            return
        
        total_selected = sum(len(objects) for objects in self.selected_objects.values())
        if total_selected == 0:
            QMessageBox.warning(self, "No Objects Selected", "Please select at least one object to generate.")
            return
        
        # Start generation
        self.log_text.clear()
        self.progress_bar.setValue(0)
        self.progress_bar.setVisible(True)
        self.generate_btn.setEnabled(False)
        
        # Create and start worker thread with template selections
        self.worker = SqlGeneratorWorker(
            self.project, 
            self.output_dir_edit.text(),
            self.selected_objects.copy(),
            single_file=self.single_file_checkbox.isChecked(),
            single_filename=self.single_filename_edit.text().strip(),
            template_selections=self.template_selections.copy()
        )
        
        self.worker.progress_updated.connect(self.progress_bar.setValue)
        self.worker.log_message.connect(self._log_message)
        self.worker.finished.connect(self._on_generation_finished)
        self.worker.error_occurred.connect(self._on_generation_error)
        
        self.worker.start()
    
    def _log_message(self, message):
        """Add message to log."""
        self.log_text.append(message)
        # Auto-scroll to bottom
        scrollbar = self.log_text.verticalScrollBar()
        scrollbar.setValue(scrollbar.maximum())
        QApplication.processEvents()  # Update UI
    
    def _on_generation_finished(self):
        """Handle successful generation completion."""
        self.progress_bar.setValue(0)
        self.generate_btn.setEnabled(True)        
    
    def _on_generation_error(self, error_message):
        """Handle generation error."""
        self.generate_btn.setEnabled(True)
        self._log_message(f"‚ùå {error_message}")
        QMessageBox.critical(self, "Generation Error", error_message)
    
    def closeEvent(self, event):
        """Handle dialog close."""
        if self.worker and self.worker.isRunning():
            self.worker.quit()
            self.worker.wait()
        event.accept()