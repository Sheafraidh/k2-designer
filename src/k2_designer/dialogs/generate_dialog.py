"""
SQL Generation Dialog for generating database scripts.
"""

import sys
import os
from typing import List, Dict, Any

try:
    from jinja2 import Environment, FileSystemLoader, Template
    JINJA2_AVAILABLE = True
except ImportError:
    JINJA2_AVAILABLE = False
    print("Warning: jinja2 not available, falling back to basic SQL generation")

# Suppress macOS NSOpenPanel warning
if sys.platform == "darwin":
    import io
    import contextlib
    
    @contextlib.contextmanager
    def suppress_stdout_stderr():
        """Suppress stdout and stderr temporarily."""
        with open(os.devnull, "w") as devnull:
            old_stdout = sys.stdout
            old_stderr = sys.stderr
            try:
                sys.stdout = devnull
                sys.stderr = devnull
                yield
            finally:
                sys.stdout = old_stdout
                sys.stderr = old_stderr

from PyQt6.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QPushButton, 
                             QTabWidget, QTreeWidget, QTreeWidgetItem, QCheckBox,
                             QLabel, QLineEdit, QFileDialog, QProgressBar, 
                             QTextEdit, QSplitter, QGroupBox, QMessageBox,
                             QApplication)
from PyQt6.QtCore import Qt, QThread, pyqtSignal
from PyQt6.QtGui import QFont


class SqlGeneratorWorker(QThread):
    """Worker thread for generating SQL files."""
    
    progress_updated = pyqtSignal(int)
    log_message = pyqtSignal(str)
    finished = pyqtSignal()
    error_occurred = pyqtSignal(str)
    
    def __init__(self, project, output_dir: str, selected_objects: Dict[str, List[Any]], 
                 single_file: bool = False, single_filename: str = "database_objects.sql"):
        super().__init__()
        self.project = project
        self.output_dir = output_dir
        self.selected_objects = selected_objects
        self.single_file = single_file
        self.single_filename = single_filename or "database_objects.sql"
        self.total_objects = sum(len(objects) for objects in selected_objects.values())
        self.current_progress = 0
        self._setup_templates()
    
    def _setup_templates(self):
        """Setup Jinja2 template environment."""
        self.jinja_env = None
        self.table_template = None
        self.sequence_template = None
        self.user_template = None
        
        if JINJA2_AVAILABLE:
            # Get the templates directory path
            current_dir = os.path.dirname(os.path.abspath(__file__))
            project_root = os.path.dirname(os.path.dirname(os.path.dirname(current_dir)))
            templates_dir = os.path.join(project_root, 'templates')
            
            if os.path.exists(templates_dir):
                try:
                    self.jinja_env = Environment(loader=FileSystemLoader(templates_dir))
                    
                    # Load templates
                    self.table_template = self.jinja_env.get_template('create_table.sql.j2')
                    self.sequence_template = self.jinja_env.get_template('create_sequence.sql.j2')
                    self.user_template = self.jinja_env.get_template('create_user.sql.j2')
                    
                    print(f"‚úÖ Loaded Jinja2 templates from: {templates_dir}")
                except Exception as e:
                    print(f"‚ö†Ô∏è Error loading Jinja2 templates: {e}")
                    self.jinja_env = None
            else:
                print(f"‚ö†Ô∏è Templates directory not found: {templates_dir}")
    
    def run(self):
        """Generate SQL files for selected objects."""
        try:
            self.log_message.emit("üöÄ Starting SQL generation...")
            self.log_message.emit(f"üìÅ Output directory: {self.output_dir}")
            
            if self.single_file:
                self._generate_single_file()
            else:
                self._generate_separate_files()
            
            self.log_message.emit("‚úÖ SQL generation completed successfully!")
            self.finished.emit()
            
        except Exception as e:
            self.error_occurred.emit(f"Error during generation: {str(e)}")
    
    def _generate_single_file(self):
        """Generate all objects into a single SQL file."""
        filepath = os.path.join(self.output_dir, self.single_filename)
        self.log_message.emit(f"üìÑ Generating single file: {self.single_filename}")
        
        sql_parts = []
        sql_parts.append("-- Database Objects SQL Script")
        sql_parts.append("-- Generated by K2 Designer")
        sql_parts.append(f"-- Total objects: {self.total_objects}")
        sql_parts.append("")
        
        # Generate tables
        if 'tables' in self.selected_objects:
            sql_parts.append("-- ==========================================")
            sql_parts.append("-- TABLES")
            sql_parts.append("-- ==========================================")
            sql_parts.append("")
            
            for table in self.selected_objects['tables']:
                sql_parts.append(self._create_table_sql(table))
                sql_parts.append("")
                self._update_progress()
        
        # Generate sequences
        if 'sequences' in self.selected_objects:
            sql_parts.append("-- ==========================================")
            sql_parts.append("-- SEQUENCES")
            sql_parts.append("-- ==========================================")
            sql_parts.append("")
            
            for sequence in self.selected_objects['sequences']:
                sql_parts.append(self._create_sequence_sql(sequence))
                sql_parts.append("")
                self._update_progress()
        
        # Generate users/owners
        if 'owners' in self.selected_objects:
            sql_parts.append("-- ==========================================")
            sql_parts.append("-- USERS/OWNERS")
            sql_parts.append("-- ==========================================")
            sql_parts.append("")
            
            for owner in self.selected_objects['owners']:
                sql_parts.append(self._create_owner_sql(owner))
                sql_parts.append("")
                self._update_progress()
        
        # Write to file
        try:
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write("\n".join(sql_parts))
            
            self.log_message.emit(f"‚úÖ Generated: {self.single_filename}")
            
        except Exception as e:
            self.log_message.emit(f"‚ùå Error generating {self.single_filename}: {str(e)}")
    
    def _generate_separate_files(self):
        """Generate separate files for each object."""
        # Generate tables
        if 'tables' in self.selected_objects:
            for table in self.selected_objects['tables']:
                self._generate_table_sql(table)
                self._update_progress()
        
        # Generate sequences
        if 'sequences' in self.selected_objects:
            for sequence in self.selected_objects['sequences']:
                self._generate_sequence_sql(sequence)
                self._update_progress()
        
        # Generate users/owners
        if 'owners' in self.selected_objects:
            for owner in self.selected_objects['owners']:
                self._generate_owner_sql(owner)
                self._update_progress()
    
    def _update_progress(self):
        """Update progress."""
        self.current_progress += 1
        progress_percent = int((self.current_progress / self.total_objects) * 100)
        self.progress_updated.emit(progress_percent)
    
    def _generate_table_sql(self, table):
        """Generate SQL for a table."""
        filename = f"{table.name.lower()}.sql"
        filepath = os.path.join(self.output_dir, filename)
        
        try:
            sql_content = self._create_table_sql(table)
            
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(sql_content)
            
            self.log_message.emit(f"üìÑ Generated: {filename}")
            
        except Exception as e:
            self.log_message.emit(f"‚ùå Error generating {filename}: {str(e)}")
    
    def _generate_sequence_sql(self, sequence):
        """Generate SQL for a sequence."""
        filename = f"{sequence.name.lower()}_seq.sql"
        filepath = os.path.join(self.output_dir, filename)
        
        try:
            sql_content = self._create_sequence_sql(sequence)
            
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(sql_content)
            
            self.log_message.emit(f"üìÑ Generated: {filename}")
            
        except Exception as e:
            self.log_message.emit(f"‚ùå Error generating {filename}: {str(e)}")
    
    def _generate_owner_sql(self, owner):
        """Generate SQL for an owner/user."""
        filename = f"{owner.name.lower()}_user.sql"
        filepath = os.path.join(self.output_dir, filename)
        
        try:
            sql_content = self._create_owner_sql(owner)
            
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(sql_content)
            
            self.log_message.emit(f"üìÑ Generated: {filename}")
            
        except Exception as e:
            self.log_message.emit(f"‚ùå Error generating {filename}: {str(e)}")
    
    def _create_table_sql(self, table) -> str:
        """Create CREATE TABLE SQL statement using Jinja2 template if available."""
        if self.table_template:
            try:
                # Use Jinja2 template
                return self.table_template.render(table=table)
            except Exception as e:
                print(f"‚ö†Ô∏è Error rendering table template, falling back to basic generation: {e}")
        
        # Fallback to basic SQL generation
        sql_parts = []
        
        # Table creation
        sql_parts.append(f"-- Table: {table.owner}.{table.name}")
        sql_parts.append(f"-- Generated by K2 Designer")
        sql_parts.append("")
        sql_parts.append(f"CREATE TABLE {table.owner}.{table.name} (")
        
        # Columns
        column_definitions = []
        for column in table.columns:
            col_def = f"    {column.name} {column.data_type}"
            if not column.nullable:
                col_def += " NOT NULL"
            if column.default:
                col_def += f" DEFAULT {column.default}"
            column_definitions.append(col_def)
        
        sql_parts.append(",\n".join(column_definitions))
        sql_parts.append(");")
        
        # Comments
        if table.comment:
            sql_parts.append("")
            sql_parts.append(f"COMMENT ON TABLE {table.owner}.{table.name} IS '{table.comment}';")
        
        for column in table.columns:
            if column.comment:
                sql_parts.append(f"COMMENT ON COLUMN {table.owner}.{table.name}.{column.name} IS '{column.comment}';")
        
        return "\n".join(sql_parts)
    
    def _create_sequence_sql(self, sequence) -> str:
        """Create CREATE SEQUENCE SQL statement using Jinja2 template if available."""
        if self.sequence_template:
            try:
                # Use Jinja2 template
                return self.sequence_template.render(sequence=sequence)
            except Exception as e:
                print(f"‚ö†Ô∏è Error rendering sequence template, falling back to basic generation: {e}")
        
        # Fallback to basic SQL generation
        sql_parts = []
        
        sql_parts.append(f"-- Sequence: {sequence.owner}.{sequence.name}")
        sql_parts.append(f"-- Generated by K2 Designer")
        sql_parts.append("")
        
        seq_sql = f"CREATE SEQUENCE {sequence.owner}.{sequence.name}"
        
        if sequence.start_with is not None:
            seq_sql += f" START WITH {sequence.start_with}"
        if sequence.increment_by is not None:
            seq_sql += f" INCREMENT BY {sequence.increment_by}"
        if sequence.min_value is not None:
            seq_sql += f" MINVALUE {sequence.min_value}"
        if sequence.max_value is not None:
            seq_sql += f" MAXVALUE {sequence.max_value}"
        if sequence.cache_size is not None:
            seq_sql += f" CACHE {sequence.cache_size}"
        if sequence.cycle:
            seq_sql += " CYCLE"
        else:
            seq_sql += " NOCYCLE"
        
        seq_sql += ";"
        sql_parts.append(seq_sql)
        
        if sequence.comment:
            sql_parts.append("")
            sql_parts.append(f"COMMENT ON SEQUENCE {sequence.owner}.{sequence.name} IS '{sequence.comment}';")
        
        return "\n".join(sql_parts)
    
    def _create_owner_sql(self, owner) -> str:
        """Create user/owner SQL statements using Jinja2 template if available."""
        if self.user_template:
            try:
                # Use Jinja2 template
                return self.user_template.render(owner=owner)
            except Exception as e:
                print(f"‚ö†Ô∏è Error rendering user template, falling back to basic generation: {e}")
        
        # Fallback to basic SQL generation
        sql_parts = []
        
        sql_parts.append(f"-- User: {owner.name}")
        sql_parts.append(f"-- Generated by K2 Designer")
        sql_parts.append("")
        
        # Create user
        sql_parts.append(f"CREATE USER {owner.name}")
        if owner.default_tablespace:
            sql_parts.append(f"    DEFAULT TABLESPACE {owner.default_tablespace}")
        if owner.temp_tablespace:
            sql_parts.append(f"    TEMPORARY TABLESPACE {owner.temp_tablespace}")
        if owner.default_index_tablespace:
            sql_parts.append(f"    DEFAULT TABLESPACE FOR INDEXES {owner.default_index_tablespace}")
        sql_parts.append(";")
        
        # Grant basic privileges
        sql_parts.append("")
        sql_parts.append(f"GRANT CONNECT TO {owner.name};")
        sql_parts.append(f"GRANT RESOURCE TO {owner.name};")
        
        # Add comment if available
        if owner.comment:
            sql_parts.append("")
            sql_parts.append(f"COMMENT ON USER {owner.name} IS '{owner.comment}';")
        
        return "\n".join(sql_parts)


class GenerateDialog(QDialog):
    """Dialog for generating SQL scripts from project objects."""
    
    def __init__(self, project, parent=None):
        super().__init__(parent)
        self.project = project
        self.selected_objects = {'tables': [], 'sequences': [], 'owners': []}
        self.worker = None
        
        self.setWindowTitle("Generate SQL Scripts")
        self.setModal(True)
        self.resize(800, 600)
        
        self._setup_ui()
        self._populate_trees()
    
    def _setup_ui(self):
        """Setup the dialog UI."""
        layout = QVBoxLayout(self)
        
        # Output directory selection
        dir_group = QGroupBox("Output Directory")
        dir_layout = QHBoxLayout(dir_group)
        
        self.output_dir_edit = QLineEdit()
        self.output_dir_edit.setPlaceholderText("Select output directory...")
        self.browse_btn = QPushButton("Browse...")
        self.browse_btn.clicked.connect(self._browse_output_dir)
        
        dir_layout.addWidget(QLabel("Output Directory:"))
        dir_layout.addWidget(self.output_dir_edit)
        dir_layout.addWidget(self.browse_btn)
        
        layout.addWidget(dir_group)
        
        # Generation options
        options_group = QGroupBox("Generation Options")
        options_layout = QVBoxLayout(options_group)
        
        self.single_file_checkbox = QCheckBox("Generate all objects to a single file")
        self.single_file_checkbox.setToolTip("When checked, all selected objects will be generated into one SQL file instead of separate files")
        
        single_file_layout = QHBoxLayout()
        single_file_layout.addWidget(self.single_file_checkbox)
        
        self.single_filename_edit = QLineEdit("database_objects.sql")
        self.single_filename_edit.setEnabled(False)
        self.single_filename_edit.setToolTip("Filename for the combined SQL file")
        
        single_file_layout.addWidget(QLabel("Filename:"))
        single_file_layout.addWidget(self.single_filename_edit)
        single_file_layout.addStretch()
        
        options_layout.addLayout(single_file_layout)
        
        # Connect checkbox to enable/disable filename field
        self.single_file_checkbox.toggled.connect(self._on_single_file_toggled)
        
        layout.addWidget(options_group)
        
        # Main splitter
        splitter = QSplitter(Qt.Orientation.Vertical)
        
        # Object selection tabs
        selection_group = QGroupBox("Select Objects to Generate")
        selection_layout = QVBoxLayout(selection_group)
        
        self.tab_widget = QTabWidget()
        
        # Tables tab
        self.tables_tree = QTreeWidget()
        self.tables_tree.setHeaderLabels(["Tables", "Owner", "Columns"])
        self.tables_tree.itemChanged.connect(self._on_table_item_changed)
        self.tab_widget.addTab(self.tables_tree, "Tables")
        
        # Sequences tab
        self.sequences_tree = QTreeWidget()
        self.sequences_tree.setHeaderLabels(["Sequences", "Owner", "Properties"])
        self.sequences_tree.itemChanged.connect(self._on_sequence_item_changed)
        self.tab_widget.addTab(self.sequences_tree, "Sequences")
        
        # Owners/Users tab
        self.owners_tree = QTreeWidget()
        self.owners_tree.setHeaderLabels(["Users/Owners", "Default Tablespace", "Properties"])
        self.owners_tree.itemChanged.connect(self._on_owner_item_changed)
        self.tab_widget.addTab(self.owners_tree, "Users")
        
        selection_layout.addWidget(self.tab_widget)
        splitter.addWidget(selection_group)
        
        # Progress and log section
        progress_group = QGroupBox("Generation Progress")
        progress_layout = QVBoxLayout(progress_group)
        
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        progress_layout.addWidget(self.progress_bar)
        
        self.log_text = QTextEdit()
        self.log_text.setMaximumHeight(150)
        self.log_text.setFont(QFont("Consolas", 9))
        progress_layout.addWidget(self.log_text)
        
        splitter.addWidget(progress_group)
        layout.addWidget(splitter)
        
        # Buttons
        button_layout = QHBoxLayout()
        
        self.select_all_btn = QPushButton("Select All")
        self.select_all_btn.clicked.connect(self._select_all)
        
        self.select_none_btn = QPushButton("Select None")
        self.select_none_btn.clicked.connect(self._select_none)
        
        button_layout.addWidget(self.select_all_btn)
        button_layout.addWidget(self.select_none_btn)
        button_layout.addStretch()
        
        self.generate_btn = QPushButton("Generate SQL")
        self.generate_btn.clicked.connect(self._generate_sql)
        
        self.close_btn = QPushButton("Close")
        self.close_btn.clicked.connect(self.close)
        
        button_layout.addWidget(self.generate_btn)
        button_layout.addWidget(self.close_btn)
        
        layout.addLayout(button_layout)
    
    def _browse_output_dir(self):
        """Browse for output directory."""
        if sys.platform == "darwin":
            # Suppress macOS NSOpenPanel warning
            with suppress_stdout_stderr():
                dir_path = QFileDialog.getExistingDirectory(
                    self, "Select Output Directory", ""
                )
        else:
            dir_path = QFileDialog.getExistingDirectory(
                self, "Select Output Directory", ""
            )
        
        if dir_path:
            self.output_dir_edit.setText(dir_path)
    
    def _populate_trees(self):
        """Populate the tree widgets with project objects."""
        # Populate tables
        for table in self.project.tables:
            item = QTreeWidgetItem(self.tables_tree)
            item.setText(0, table.name)
            item.setText(1, table.owner)
            item.setText(2, f"{len(table.columns)} columns")
            item.setFlags(item.flags() | Qt.ItemFlag.ItemIsUserCheckable)
            item.setCheckState(0, Qt.CheckState.Unchecked)
            item.setData(0, Qt.ItemDataRole.UserRole, table)
        
        # Populate sequences
        for sequence in self.project.sequences:
            item = QTreeWidgetItem(self.sequences_tree)
            item.setText(0, sequence.name)
            item.setText(1, sequence.owner)
            item.setText(2, f"Start: {sequence.start_with}, Inc: {sequence.increment_by}")
            item.setFlags(item.flags() | Qt.ItemFlag.ItemIsUserCheckable)
            item.setCheckState(0, Qt.CheckState.Unchecked)
            item.setData(0, Qt.ItemDataRole.UserRole, sequence)
        
        # Populate owners
        for owner in self.project.owners:
            item = QTreeWidgetItem(self.owners_tree)
            item.setText(0, owner.name)
            item.setText(1, owner.default_tablespace or "")
            item.setText(2, f"Editionable: {owner.editionable}")
            item.setFlags(item.flags() | Qt.ItemFlag.ItemIsUserCheckable)
            item.setCheckState(0, Qt.CheckState.Unchecked)
            item.setData(0, Qt.ItemDataRole.UserRole, owner)
        
        # Expand all trees
        self.tables_tree.expandAll()
        self.sequences_tree.expandAll()
        self.owners_tree.expandAll()
    
    def _on_table_item_changed(self, item, column):
        """Handle table item check state change."""
        if column == 0:  # Only handle first column
            table = item.data(0, Qt.ItemDataRole.UserRole)
            if item.checkState(0) == Qt.CheckState.Checked:
                if table not in self.selected_objects['tables']:
                    self.selected_objects['tables'].append(table)
            else:
                if table in self.selected_objects['tables']:
                    self.selected_objects['tables'].remove(table)
    
    def _on_sequence_item_changed(self, item, column):
        """Handle sequence item check state change."""
        if column == 0:
            sequence = item.data(0, Qt.ItemDataRole.UserRole)
            if item.checkState(0) == Qt.CheckState.Checked:
                if sequence not in self.selected_objects['sequences']:
                    self.selected_objects['sequences'].append(sequence)
            else:
                if sequence in self.selected_objects['sequences']:
                    self.selected_objects['sequences'].remove(sequence)
    
    def _on_owner_item_changed(self, item, column):
        """Handle owner item check state change."""
        if column == 0:
            owner = item.data(0, Qt.ItemDataRole.UserRole)
            if item.checkState(0) == Qt.CheckState.Checked:
                if owner not in self.selected_objects['owners']:
                    self.selected_objects['owners'].append(owner)
            else:
                if owner in self.selected_objects['owners']:
                    self.selected_objects['owners'].remove(owner)
    
    def _on_single_file_toggled(self, checked):
        """Handle single file checkbox toggle."""
        self.single_filename_edit.setEnabled(checked)
        if checked:
            self.single_filename_edit.setFocus()
    
    def _select_all(self):
        """Select all items in current tab."""
        current_widget = self.tab_widget.currentWidget()
        self._set_all_items_checked(current_widget, True)
    
    def _select_none(self):
        """Deselect all items in current tab."""
        current_widget = self.tab_widget.currentWidget()
        self._set_all_items_checked(current_widget, False)
    
    def _set_all_items_checked(self, tree_widget, checked):
        """Set all items in tree widget to checked/unchecked."""
        for i in range(tree_widget.topLevelItemCount()):
            item = tree_widget.topLevelItem(i)
            item.setCheckState(0, Qt.CheckState.Checked if checked else Qt.CheckState.Unchecked)
    
    def _generate_sql(self):
        """Start SQL generation process."""
        # Validate inputs
        if not self.output_dir_edit.text().strip():
            QMessageBox.warning(self, "No Directory", "Please select an output directory.")
            return
        
        if not os.path.exists(self.output_dir_edit.text()):
            QMessageBox.warning(self, "Invalid Directory", "The selected output directory does not exist.")
            return
        
        total_selected = sum(len(objects) for objects in self.selected_objects.values())
        if total_selected == 0:
            QMessageBox.warning(self, "No Objects Selected", "Please select at least one object to generate.")
            return
        
        # Start generation
        self.log_text.clear()
        self.progress_bar.setValue(0)
        self.progress_bar.setVisible(True)
        self.generate_btn.setEnabled(False)
        
        # Create and start worker thread
        self.worker = SqlGeneratorWorker(
            self.project, 
            self.output_dir_edit.text(),
            self.selected_objects.copy(),
            single_file=self.single_file_checkbox.isChecked(),
            single_filename=self.single_filename_edit.text().strip()
        )
        
        self.worker.progress_updated.connect(self.progress_bar.setValue)
        self.worker.log_message.connect(self._log_message)
        self.worker.finished.connect(self._on_generation_finished)
        self.worker.error_occurred.connect(self._on_generation_error)
        
        self.worker.start()
    
    def _log_message(self, message):
        """Add message to log."""
        self.log_text.append(message)
        # Auto-scroll to bottom
        scrollbar = self.log_text.verticalScrollBar()
        scrollbar.setValue(scrollbar.maximum())
        QApplication.processEvents()  # Update UI
    
    def _on_generation_finished(self):
        """Handle successful generation completion."""
        self.progress_bar.setValue(0)
        self.generate_btn.setEnabled(True)        
    
    def _on_generation_error(self, error_message):
        """Handle generation error."""
        self.generate_btn.setEnabled(True)
        self._log_message(f"‚ùå {error_message}")
        QMessageBox.critical(self, "Generation Error", error_message)
    
    def closeEvent(self, event):
        """Handle dialog close."""
        if self.worker and self.worker.isRunning():
            self.worker.quit()
            self.worker.wait()
        event.accept()